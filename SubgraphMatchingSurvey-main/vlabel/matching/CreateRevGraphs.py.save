import networkx as nx
import random
import os
from collections import deque
import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
def random_walk_induced_subgraph(G, num_nodes_to_visit=16):
    if num_nodes_to_visit > len(G):
        raise ValueError("num_nodes_to_visit exceeds number of nodes in the graph.")

    start_node = random.choice(list(G.nodes))
    visited = {start_node}
    current = start_node

    while len(visited) < num_nodes_to_visit:
        neighbors = list(G.neighbors(current))
        if not neighbors:
            current = random.choice(list(visited))
            continue
        current = random.choice(neighbors)
        visited.add(current)

    return G.subgraph(visited).copy()



    
def bfs_biased_random_walk(G, num_nodes_to_visit=16, revisit_prob=0.1):
    if num_nodes_to_visit > len(G):
        raise ValueError("num_nodes_to_visit exceeds number of nodes in the graph.")

    # Ensure the start node is suitable
    while True:
        start_node = random.choice(list(G.nodes))
        if len(list(G.neighbors(start_node))) < 5:
            continue
        reachable = list(nx.node_connected_component(G, start_node))
        if len(reachable) >= num_nodes_to_visit:
            break

    # Start with the start node + up to 3 of its neighbors
    neighbors = list(G.neighbors(start_node))
    random.shuffle(neighbors)
    initial_neighbors = neighbors[:min(3, len(neighbors))]

    visited = set([start_node] + initial_neighbors)
    current = random.choice(list(visited))  # Start from any in the seed group

    # Continue walk until target number of unique nodes visited
    while len(visited) < num_nodes_to_visit:
        neighbors = list(G.neighbors(current))
        if not neighbors:
            current = random.choice(list(visited))
            continue

        unvisited_neighbors = [n for n in neighbors if n not in visited]
        visited_neighbors = [n for n in neighbors if n in visited]

        if unvisited_neighbors and random.random() > revisit_prob:
            next_node = random.choice(unvisited_neighbors)
        elif visited_neighbors:
            next_node = random.choice(visited_neighbors)
        else:
            next_node = random.choice(neighbors)

        visited.add(next_node)
        current = next_node

    return G.subgraph(visited).copy()
def save_graph_to_file(graph, graph_type, index, folder="graphs", type_map=None):
    import os
    os.makedirs(folder, exist_ok=True)

    type_id = type_map.get(graph_type, 0) if type_map else 0
    num_nodes = graph.number_of_nodes()
    num_edges = graph.number_of_edges()
    filename = os.path.join(folder, f"{graph_type}_{index}.txt")

    # Create a mapping from original node IDs to new IDs from 0 to n-1
    node_mapping = {old_id: new_id for new_id, old_id in enumerate(graph.nodes())}

    with open(filename, 'w') as f:
        f.write(f"t {num_nodes} {num_edges}\n")
        for old_id in graph.nodes:
            new_id = node_mapping[old_id]
            label = graph.nodes[old_id].get('label', 0)
            degree = graph.degree[old_id]
            f.write(f"v {new_id} {label} {degree}\n")
        for u, v in graph.edges:
            f.write(f"e {node_mapping[u]} {node_mapping[v]} 0\n")
def save_graph_to_file1(graph, graph_type, index, folder="graphs", type_map=None):
    import os
    os.makedirs(folder, exist_ok=True)

    type_id = type_map.get(graph_type, 0)
    num_nodes = graph.number_of_nodes()
    num_edges = graph.number_of_edges()
    filename = os.path.join(folder, f"{graph_type}_{index}.txt")

    with open(filename, 'w') as f:
        f.write(f"t {num_nodes} {num_edges}\n")
        for node in graph.nodes:
            label = graph.nodes[node].get('label', 0)
            degree = graph.degree[node]
            f.write(f"v {node} {label} {degree}\n")
        for u, v in graph.edges:
            f.write(f"e {u} {v} 0\n")

def get_random_path(G, length=16):
    for _ in range(100000):
        start = random.choice(list(G.nodes))
        try:
            path = nx.single_source_shortest_path(G, start, cutoff=length-1)
            long_paths = [p for p in path.values() if len(p) == length]
            if long_paths:
                return G.subgraph(long_paths[0]).copy()
        except:
            continue
    return None

def get_tall_tree2(G, size=16):
    for _ in range(100000):
        start = random.choice(list(G.nodes))
        path = [start]
        visited = set([start])

        current = start
        while len(path) < size + 1:
            neighbors = [n for n in G.neighbors(current) if n not in visited]
            if not neighbors:
                break  # dead end
            next_node = random.choice(neighbors)
            path.append(next_node)
            visited.add(next_node)
            current = next_node

        if len(path) == size + 1:
            # Convert path to a tree
            tree = nx.DiGraph()
            tree.add_edges_from(zip(path[:-1], path[1:]))
            return tree

    return None
def get_tall(G,size=16):
    cont=True
    counter=0
    dfs=True
    n = G.number_of_nodes()
    m = G.number_of_edges()
    nm=0.1
    while(cont):
        #if (counter%5000==0):
        #    nm=nm+0.1
        #if(counter%1000==0):
        #    dfs=False
        if(dfs):
            G1=random_walk_induced_subgraph(G)
        else:
            G1=bfs_biased_random_walk(G,revisit_prob=nm)
        depth = nx.diameter(G1)
        avg_branching = sum(dict(G1.degree()).values()) / 16
        if depth >= 3 and avg_branching <= 2:
            cont=False
            return G1
        counter=counter+1
def get_tall_wide(G,size=16):
    cont=True
    counter=0
    dfs=True
    n = G.number_of_nodes()
    m = G.number_of_edges()
    nm=0.1
    while(cont):
        if (counter%5000==0):
            nm=nm+0.1
        if(counter%1000==0):
            dfs=False
        if(dfs):
            G1=random_walk_induced_subgraph(G)
        else:
            G1=bfs_biased_random_walk(G,revisit_prob=nm)
        depth = nx.diameter(G1)
        avg_branching = sum(dict(G1.degree()).values()) / 16
        if depth >= 3 and avg_branching > 2:
            cont=False
            print(dfs,counter,nm)
            return G1
        counter=counter+1
def bfs_nodes_at_most_k_hops(G, start, k=2):
    visited = {start}
    queue = deque([(start, 0)])

    while queue:
        node, depth = queue.popleft()
        if depth >= k:
            continue

        for neighbor in G.neighbors(node):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, depth + 1))

    return visited
def diameter_limited_high_degree_subgraph(G, min_avg_degree=3, max_diameter=2, target_size=16, max_tries=100):
    """
    1. Perform 2-hop BFS from a random node.
    2. Prune nodes until:
        - Diameter ≤ max_diameter
        - Average degree > min_avg_degree
        - Size == target_size
    """
    for _ in range(max_tries):
        start = random.choice(list(G.nodes))
        bfs_node_set = bfs_nodes_at_most_k_hops(G, start, k=2)
        H = G.subgraph(bfs_node_set).copy()
        # Get 2-hop BFS neighborhood
        if H.number_of_nodes() < target_size:
            continue

        # Reduce subgraph until it has exactly target_size nodes
        while H.number_of_nodes() > target_size:
            if not nx.is_connected(H):
                largest_cc = max(nx.connected_components(H), key=len)
                H = H.subgraph(largest_cc).copy()
                continue

            # Greedily remove lowest-degree, most peripheral node
            local_center = max(H.degree, key=lambda x: x[1])[0]

# Use it for distance-based sorting
            degree_sorted = sorted(
                H.degree,
                key=lambda x: (x[1], -nx.shortest_path_length(H, source=local_center, target=x[0]))
                )
            node_to_remove = degree_sorted[0][0]
            H.remove_node(node_to_remove)

        # Final check: size == target, diameter ≤ 2, avg degree > threshold
        if H.number_of_nodes() == target_size:
            if nx.is_connected(H):
                diameter = nx.diameter(H)
                avg_deg = sum(dict(H.degree()).values()) / H.number_of_nodes()

                if diameter <= max_diameter and avg_deg > min_avg_degree:
                    return H

    raise RuntimeError("Could not find a suitable subgraph after max_tries.")
def diameter_limited_low_degree_subgraph(G, max_avg_degree=2, max_diameter=2, target_size=16, max_tries=100):
    """
    Find a flat narrow subgraph: low average degree (≤ max_avg_degree), diameter ≤ max_diameter,
    and exactly target_size nodes.
    """
    for _ in range(max_tries):
        start = random.choice(list(G.nodes))
        bfs_node_set = bfs_nodes_at_most_k_hops(G, start, k=2)
        H = G.subgraph(bfs_node_set).copy()
        H1=H
        if H.number_of_nodes() < target_size:
            continue

        # Reduce node count to target_size
        while H.number_of_nodes() > target_size:
            if not nx.is_connected(H):
                largest_cc = max(nx.connected_components(H), key=len)
                H = H.subgraph(largest_cc).copy()
                continue

            # Remove highest-degree, most central node
            local_center = max(H.degree, key=lambda x: x[1])[0]
            degree_sorted = sorted(
                H.degree,
                key=lambda x: (-x[1], nx.shortest_path_length(H, source=local_center, target=x[0]))
            )
            node_to_remove = degree_sorted[0][0]
            H.remove_node(node_to_remove)

        if not nx.is_connected(H):
            continue

        # Now try reducing average degree by removing edges
        while True:
            avg_deg = sum(dict(H.degree()).values()) / H.number_of_nodes()
            if avg_deg <= max_avg_degree:
                break

            removable_edges = list(H.edges)
            edge_removed = False
            for u, v in sorted(removable_edges, key=lambda e: -(H.degree[e[0]] + H.degree[e[1]])):
                H.remove_edge(u, v)
                if nx.is_connected(H) and nx.diameter(H) <= max_diameter:
                    edge_removed = True
                    break  # Accept this edge removal
                else:
                    H.add_edge(u, v)  # Undo removal if it breaks constraints

            if not edge_removed:
                break  # No more removable edges without violating constraints

        # Final check
        if (
            H.number_of_nodes() == target_size
            and nx.is_connected(H)
            and nx.diameter(H) <= max_diameter
            and (sum(dict(H.degree()).values()) / H.number_of_nodes()) <= max_avg_degree
        ):
            return H
    return 
def get_wide_flat(G,size=16):
    cont=True
    counter=1
    dfs=False
    n = G.number_of_nodes()
    m = G.number_of_edges()
    nm=0.1
    while(cont):
        if (counter%10000==0):
            nm=nm+0.1
            print(nm)
        if(counter%5000):
            dfs=not dfs
        if(dfs):
            #G1=random_walk_induced_subgraph(G)
            G1=diameter_limited_high_degree_subgraph(G)
        else:
            #G1=explore_dense_local_subgraph(G,2,2,100)
            #G1=diameter_limited_high_degree_subgraph(G)
            G1=bfs_biased_random_walk(G,revisit_prob=nm)
            #print("slow")
        depth = nx.diameter(G1)
        avg_branching = sum(dict(G1.degree()).values()) / 16
        counter=counter+1
        if (depth<=2):
            print("interesting")
        if depth <= 2 and avg_branching > 2:
            cont=False
            print(counter,nm)
            return G1
def get_flat_narrow_graph(G,size=16):
    cont=True
    counter=0
    dfs=False
    n = G.number_of_nodes()
    m = G.number_of_edges()
    nm=0.3
    while(cont):
        if (counter%10000==0):
            nm=nm+0.1
        if(counter%5000==0):
            dfs=not dfs
        if(dfs and counter<20000):
            G1=random_walk_induced_subgraph(G)
        elif(dfs and counter>0):
            G1=diameter_limited_low_degree_subgraph(G)
        else:           
            G1=bfs_biased_random_walk(G,revisit_prob=nm)
        if (G1==None):
            counter=counter+1
            continue
        depth = nx.diameter(G1)
        counter=counter+1
        avg_branching = sum(dict(G1.degree()).values()) / 16
        if depth <= 2 and avg_branching <= 2:
            cont=False
            return G1
def explore_dense_local_subgraph(G, min_branching=2, max_depth=2, max_tries=1000):
    """
    Explore G to find a subgraph rooted at a node such that:
    - Max depth from root is <= max_depth
    - Average branching factor > min_branching
    """
    for _ in range(max_tries):
        start = random.choice(list(G.nodes))
        if G.degree[start] < 2:
            continue  # Skip isolated or low-degree nodes

        visited = set()
        subgraph = nx.Graph()
        queue = [(start, 0)]

        while queue:
            current, depth = queue.pop(0)
            if current in visited or depth > max_depth:
                continue

            visited.add(current)

            for neighbor in G.neighbors(current):
                subgraph.add_edge(current, neighbor)
                if neighbor not in visited and depth < max_depth:
                    queue.append((neighbor, depth + 1))

        if len(subgraph.nodes) == 0:
            continue

        # Compute average branching factor
        internal_nodes = [n for n in subgraph.nodes if subgraph.degree[n] > 1]
        if len(internal_nodes) == 0:
            continue

        avg_branching = subgraph.number_of_edges() / len(internal_nodes)

        if avg_branching > min_branching:
            return subgraph

    raise RuntimeError("Could not find a suitable subgraph after max_tries.")
def get_wide_flat_tree1(G, size=16):
    for _ in range(100000):
        center = random.choice(list(G.nodes))
        neighbors = list(G.neighbors(center))
        if len(neighbors) >= size - 1:
            selected = neighbors[:size - 1]
            nodes = [center] + selected
            return G.subgraph(nodes).copy()
    return None
def get_wide_flat_tree(G, size=16):
    for _ in range(100000):
        center = random.choice(list(G.nodes))
        neighbors = list(G.neighbors(center))

        # Filter neighbors that are not connected to each other
        # to avoid creating cycles when forming a star
        valid_neighbors = []
        for n in neighbors:
            if all(not G.has_edge(n, other) for other in valid_neighbors):
                valid_neighbors.append(n)
            if len(valid_neighbors) >= size - 1:
                break

        if len(valid_neighbors) == size - 1:
            nodes = [center] + valid_neighbors
            tree = nx.Graph()
            tree.add_node(center)
            for neighbor in valid_neighbors:
                tree.add_edge(center, neighbor)
            return tree

    return None
def get_cycle1(G, length=16):
    for _ in range(100000):
        try:
            cycle = nx.find_cycle(G, orientation="ignore")
            cycle_nodes = [u for u, v in cycle]
            if len(set(cycle_nodes)) >= length:
                return G.subgraph(cycle_nodes[:length]).copy()
        except:
            continue
    return None
def get_cycle(G, length=16, max_attempts=100000):
    nodes = list(G.nodes)
    for _ in range(max_attempts):
        start = random.choice(nodes)
        walk = [start]
        position = {start: 0}
        current = start

        for _ in range(length * 3):
            neighbors = list(G.neighbors(current))
            if not neighbors:
                break
            next_node = random.choice(neighbors)
            walk.append(next_node)

            if next_node in position:
                cycle_start = position[next_node]
                cycle = walk[cycle_start:]
                if cycle[0] != cycle[-1]:
                    continue  # Not a closed cycle

                unique_nodes = set(cycle[:-1])
                if len(unique_nodes) == length:
                    # Build the cycle graph
                    cycle_edges = list(zip(cycle[:-1], cycle[1:]))
                    cycle_graph = nx.Graph()
                    cycle_graph.add_nodes_from((n, G.nodes[n]) for n in unique_nodes)
                    cycle_graph.add_edges_from(cycle_edges)

                    # Ensure every node has degree 2
                    if all(deg == 2 for _, deg in cycle_graph.degree()):
                        return cycle_graph
            else:
                position[next_node] = len(walk) - 1
                current = next_node

    return None

def generate_samples(G, num_each=20):
    samples = {
        'path': [],
        'tall_tree': [],
        'wide_flat_tree': [],
        'cycle': []
    }
    while len(samples['path']) < num_each:
        g = get_random_path(G)
        if g:
            samples['path'].append(g)
    while len(samples['tall_tree']) < num_each:
        #g = get_tall_tree(G)
        if g:
            samples['tall_tree'].append(g)
    while len(samples['wide_flat_tree']) < num_each:
        g = get_wide_flat_tree(G)
        if g:
            samples['wide_flat_tree'].append(g)
    while len(samples['cycle']) < num_each:
        g = get_cycle(G)
        if g:
            samples['cycle'].append(g)
    return samples
    return G
def generate_query_paths(base_path, dataset, qnr):
    return [
        f"{base_path}{dataset}/query_graph/query_dense_{qnr}_{qs}.graph"
        for qs in range(1, 201)
    ]

def read_undirected_graph(filepath):
    G = nx.Graph()
    with open(filepath, 'r') as f:
        lines = f.readlines()
        
        for line in lines[1:]:  # Skip the first line (t ...)
            parts = line.strip().split()
            if not parts:
                continue

            if parts[0] == 'v':
                node_id = int(parts[1])
                x = int(parts[2])
                y = int(parts[3])
                G.add_node(node_id, label=x)

            elif parts[0] == 'e':
                u = int(parts[1])
                v = int(parts[2])
                G.add_edge(u, v)

    return G
def GENrEG():
    num_nodes = 500
    #G = nx.newman_watts_strogatz_graph(num_nodes, 4, 0.3)
    G= nx.erdos_renyi_graph(num_nodes, 0.01X)
    # Assign labels to nodes with specified probabilities
    labels = [0, 1]
    probabilities = [0.3, 0.7]
    node_labels = np.random.choice(labels, size=num_nodes, p=probabilities)
    for i, label in enumerate(node_labels):
        G.nodes[i]['label'] = int(label)

    # Draw the graph
    pos = nx.spring_layout(G)
    nx.draw(G, pos, with_labels=False, node_color='blue', edge_color='skyblue', node_size=10)
    plt.show()

    # Save the graph
    save_graph_to_file(G, "randomGraph", 1, folder="../dataset/RG/query_graph/")
def generate_samples1(G, num_each=1):

    samples = {
        'path':[],
        'cycle':[],
        'tall_wide': [],
        'tall': [],
        'wide_flat': [],
        'flat_narrow': []
    }
    type_map = {
        'tall_wide': 0,
        'tall': 1,
        'wide_flat': 2,
        'flat_narrow': 3,
        'path': 4,
        'cycle':5,
        
    }

    for graph_type, generator in [
        #('tall_wide', get_tall_wide),
        #('tall', get_tall),
        #('wide_flat', get_wide_flat),        
        #('flat_narrow', get_flat_narrow_graph),
        #('path', get_random_path),
        ('cycle',get_cycle)
    ]:
        while len(samples[graph_type]) < num_each:
            g = generator(G)
            if g:
                samples[graph_type].append(g)
                print(graph_type,samples[graph_type])
                #save_graph_to_file(g, graph_type, len(samples[graph_type])-1 ,folder="../dataset/RG/query_graph/", type_map=type_map)
                save_graph_to_file(g, graph_type, len(g) ,folder="../dataset/RG/query_graph/", type_map=type_map)
    return samples

Dataset="youtube"
Query="../../../../Pilos-Subgraph_Matching/dataset/yeast/data_graph/yeast.graph"
Query="../dataset/RG/query_graph/randomGraph_1.txt"
GENrEG()
generate_samples1(read_undirected_graph(Query))
##

